
<!DOCTYPE html>
<html class="data_viz">
   <meta charset="utf-8">
   <title>Lets Visualize some Neural Networks</title>
   <style>

     //@import url(css/normalize.css);
     @import url(css/main.css);
     //@import url(css/style.css);

      #chart {
         widht: 960px;
         height: 800px;
         background-color: #f0f0f0;
      }

      .node rect {
         cursor: move;
         fill-opacity: .9;
         shape-rendering: crispEdges;
      }

      .node circle {
         cursor: move;
         fill-opacity: .9;
         //shape-rendering: crispEdges;
      }

      .node text {
         pointer-events: none;
         text-shadow: 0 1px 0 #fff;
      }

      .link {
         fill: none;
         stroke: #000;
         //stroke-opacity: .2;
      }

      .link:hover {
         stroke-opacity: .5;
      }

   </style>
   <body>

      <header>
         <p>Data Visualization CSE 512, Spring 2015</p>
      </header>

      <h1>Neural Net Visual</h1>
	<form>
		<input type = "radio" value = "Big XoR" name = "Network" id = "BigXoRNet" checked> Big XoR NetWork
		<input type = "radio" value = "Big XoR Untrained" name = "Network" id = "UnXoRNet" > Untrained XoR NetWork
		<input type = "radio" value = "Small XoR" name = "Network" id = "SmallXoRNet" > Small XoR NetWork
		<input type = "radio" value = "MNIST" name = "Network" id = "MNISTNet"> MNIST Network
		<input type = "radio" value = "Robotic" name = "NetWork" id = "RoboNet"> Robotic Network
	</form>
      <p id="chart"></p>
	<div>
		<button onclick = "Render()"> Display </button>
		<button onclick = "Reset()"> Clear </button>
	</div>

      <!-- TODO DELETE
      <aside>Drag to rearrange nodes.</aside>
      <aside>Sankey diagrams are closely related to <a href="http://en.wikipedia.org/wiki/Alluvial_diagram">alluvial diagrams</a>, which show how network structure changes over time.</aside>

      -->

      <p>The fully automatic layout is convenient for rapid visualization—positioning nodes manually is tedious! However, the algorithm is not perfect; links are drawn with partial transparency to highlight crossings. To improve readability and further disambiguate links, this example also lets you reposition nodes interactively. The algorithm could be improved in the future, say to minimize link crossing or to support loopback in cyclical networks.</p>

      <footer>
         <p>Data Visualization CSE 512, Spring 2015</p>
      </footer>

      <script src="scripts/d3.v3.min.js"></script>
      <script src="scripts/sankey.js"></script>
      <script src="scripts/queue.v1.min.js"></script>
      <script>

         var m_width = 960;
         var m_height = 800;
         var margin = {top: 20, right: 20, bottom: 20, left: 20};
         var width = m_width - margin.left - margin.right;
         var height = m_height - margin.top - margin.bottom;

         var formatNumber = d3.format(",.3f");
         var format = function(d) { return formatNumber(d); };
         var color = d3.scale.category20();

         var svg = d3.select("#chart").append("svg")
         .attr("width", m_width)
         .attr("height", m_height)
         .append("g")
         .attr("transform", "translate(" + margin.left + "," + margin.top + ")")

         svg.append("rect")
         .attr("width", m_width)
         .attr("height", m_height)
         .attr("fill", "#f0f0f0");

         //console.log([width, height]);

         var sankey = d3.sankey()
         .nodeWidth(24)
         .nodePadding(8)
         .size([width, height]);

         //var path = sankey.link();
         var path = d3.svg.diagonal()
         .source(function(d) {
            return {
               "x":d.source.y + d.source.dy,
               "y":d.source.x + sankey.nodeWidth()/2};
         })            
         .target(function(d) {
            return {
               "x":d.target.y + d.target.dy,
               "y":d.target.x + sankey.nodeWidth()/2};
         })
         .projection(function(d) { return [d.y, d.x]; });

		   function Render() {
			   var radios = document.getElementsByTagName('input');
			   	var value
			   	for (var i =0; i <radios.length; i++) {
			   		if(radios[i].type === "radio" && radios[i].checked) {
			   			value = radios[i].value;
			   		}			
			   	} 			
			   	if (value === "Big XoR") {
			   			queue()
			   			.defer(d3.json, "data/xor_sankey.json")
			   			.defer(d3.json, "data/tsne_points.json")
			   			.await(ready);
			   	}
               else if (value === "Big XoR Untrained") {
			   			queue()
			   			.defer(d3.json, "data/xor_notrain_sankey.json")
			   			.defer(d3.json, "data/tsne_points.json")
			   			.await(ready);
			   	}
               else if (value === "Small XoR") {
			   			queue()
			   			.defer(d3.json, "data/xor_smaller_sankey.json")
			   			.defer(d3.json, "data/tsne_points.json")
			   			.await(ready);
			   	}
			   	else if (value === "MNIST") {
			   			//alert("MNIST Network");
			   			queue()
			   			.defer(d3.json, "data/mnist_sankey_v2.json")
			   			.defer(d3.json, "data/tsne_points.json")
			   			.await(ready);
			   	}
			   	else {
			   	}		
			   }
		   function Reset() {
				d3.select("link").remove();
				d3.select("node").remove();
			}
		
         //queue()
         //.defer(d3.json, "data/tsne_sankey.json")
         //.defer(d3.json, "data/mnist_sankey.json")
         //.defer(d3.json, "data/mnist_sankey_v2.json")
         //.defer(d3.json, "data/xor_sankey.json")
         //.defer(d3.json, "data/xor_notrain_sankey.json")
         //.defer(d3.json, "data/xor_smaller_sankey.json")

         //.defer(d3.json, "data/tsne_points.json")
         //.defer(d3.json, "data/energy.json")
         //.await(ready);

         var mapRange = function(from, to, s) {
            return to[0] + (s - from[0]) * (to[1] - to[0]) / (from[1] - from[0]);
         };

         function ready(error, data_s, net) {

            console.log("nodes: "+data_s.nodes.length)
            console.log("links: "+data_s.links.length)
            console.log("meta:  "+data_s.meta.length)

            sankey
            .nodes(data_s.nodes)
            .links(data_s.links)
            .layout(32);

            // combine additional data into node strutures
            for (var n=0; n<data_s.nodes.length; n++) {
               data_s.nodes[n].size = data_s.meta[n].size;
               if (data_s.meta[n].pos.length == 1) {
                  data_s.nodes[n].pos = [];
                  data_s.nodes[n].pos.push(mapRange([-1, 1], [0, height], data_s.meta[n].pos[0]));

                  console.log("before: "+data_s.meta[n].pos[0]+"mapped: " +data_s.nodes[n].pos[0]);
               } else {
                  data_s.nodes[n].pos = data_s.meta[n].pos;
               }
            }
            //console.log(data_s.nodes);

            //console.log(sankey)
            // TODO these options should probably be in the json files or
            // somehow set to change depending on which network is currently visualized
            var n_scale = data_s.opt.node_scale;
            var l_scale = data_s.opt.link_scale;
            var l_opcty = data_s.opt.link_opcty;
            console.log(l_scale + " :: " + l_opcty);

            var link = svg.append("g").selectAll(".link")
            .data(data_s.links)
            .enter().append("path")
            .attr("class", "link")
            .attr("d", path)
            .style("stroke-width", function(d) { return Math.max(1, l_scale*d.value); })
            .sort(function(a, b) { return b.dy - a.dy; })
            .style("opacity", function(d) { return Math.min(0.5, d.value/l_opcty); });

            link.append("title")
            .text(function(d) {
               return d.source.name+" → "+d.target.name+"\n"
               +format(d.v1)+" → "+format(d.v2)+"\n"
               +format(d.value)+"\n"+format(d.dy);
            });

            var node = svg.append("g").selectAll(".node")
            .data(data_s.nodes)
            .enter().append("g")
            .attr("class", "node")
            .attr("transform", function(d) {
               return "translate(" + d.x + "," + d.y + ")";
            })
            .call(d3.behavior.drag()
            .origin(function(d) { return d; })
            .on("dragstart", function() { this.parentNode.appendChild(this); })
            .on("drag", dragmove));

            // rectangular sankey nodes
            /*
            node.append("rect")
               .attr("height", function(d) { return d.dy; })
               .attr("width", sankey.nodeWidth())
               .style("fill", function(d) {  })
               .style("stroke", function(d) { return d3.rgb(d.color).darker(2); })
               .append("title")
               .text(function(d) { return d.name + "\n" + format(d.value); });
               */

            //////////////////////////////////////////////
            // circular sankey nodes
            // size is weights of neurons; get min and max and scale between
            var node_max = d3.max(data_s.meta, function(d) {return d.size;});
            var node_min = d3.min(data_s.meta, function(d) {return d.size;});
            console.log("min max " + node_min+" "+node_max);

            node.append("circle")
               .attr("cx", sankey.nodeWidth()/2)
               .attr("cy", function (d) { 
                  //console.log(d.pos[0]+" : "+d.dy);
                  return d.dy;
               })
               .attr("r", function (d) { 
                  //console.log("size: "+d.size+" dy: "+d.dy);
                  //return Math.sqrt(d.size*100);
                  return mapRange([node_min, node_max], [5, 20], d.size);
                  //return Math.sqrt(d.dy);
                  })
               .style("opacity", 0.6)
               .append("title")
               .text(function(d) { return d.name + "\n"
                  + "Val: "+format(d.value)+ "\n"
                  + "L: "+d.layer+ "\n"
                  + format(d.dy) + "\n"
                  + format(d.size); });

            node.append("text")
               .attr("x", -6)
               .attr("y", function(d) { return d.dy; })
               .attr("dy", ".35em")
               .attr("text-anchor", "end")
               .attr("transform", null)
               .text(function(d) { return d.name; })
               .filter(function(d) { return d.x < width / 2; })
               .attr("x", 6 + sankey.nodeWidth())
               .attr("text-anchor", "start");

               // TODO don't allow drag and drop??
            function dragmove(d) {
               d3.select(this).attr("transform", "translate(" + d.x + "," + (d.y = Math.max(0, Math.min(height - d.dy, d3.event.y))) + ")");
               //d3.select(this).attr("transform", "translate(" + d.x + "," + (d.y = Math.max(0, Math.min(height - d.pos[0], d3.event.y)) ) + ")");
               sankey.relayout();
               link.attr("d", path);
            }

            // small multiples below
            // Nest data by symbol.
            console.log("network: "+net.network.length);

            var neurons = d3.nest()
               .key(function(d) { return d.layer; })
               .key(function(d) { return d.neuron; })
               .entries(net.network);
         }

      </script>

   </body>
</head>
